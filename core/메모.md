강의 핵심
- 제어의 역전 및 의존성 주입이 OOP의 SOLID원칙을 지키는데 있어 중요함. 이를  스프링에서 해준다.
- 웹 서비스의 특성 상, singleton 객체가 효율적임. 그러나 구현을 제대로 안하면 구린데, 이걸 스프링에서 해준다.

Config는 의존성을 주입해주는 역할을 한다.

Service단에서 구체적인 클래스를 가져오는 것은, 
배우가 상대 배우를 섭외하는 것과 같음.
배우는 역할(인터페이스)에 집중해야함.

따라서 config가 배역마다 어떤 배우를 쓸지 정해준다. 
=> 외부에서 의존성 주입!

import로 판별되는 정적인 의존성이 있고, 
실제로 어떤 인스턴스가 사용되는지에 관한 동적인 의존성이 있음.

IoC 컨테이너: 제어의 역전을 담당하는 부분. 본래 객체 내부에서
다른 객체와의 관계나 상호작용을 정의했으나, 
config에서 이를 정의하도록 변경함. 이것이 제어의 역전 예시임.
정의대로는 프로그램의 실행 흐름을 코드 내부가 아닌 외부에서 담당하는 것.
프레임워크가 하나의 예시임. 프레임워크는 고유의 생명 주기를 가지고 있음.
내 코드는 생명 주기의 특정 부분에서 실행된다.

DI컨테이너: 의존성 주입을 담당하는 부분. IoC의 의미가 너무 방대해서
따로 분리함.

ApplicationContext 객체가 스프링 빈을 관리한다. 사실 이 빈 관리기능은
BeanFactory 인터페이스에서 정의된 것. 
ApplicationContext은 그 외에 부가기능들을 제공한다.
ApplicationContext의 구현체로는 Annotation 기반의 자바 코드,
XML코드, 임의 코드에 대한 것이 존재.

->어떻게 가능한걸까? : BeanDefinition으로 메타 정보를 추상화함.

Singleton이란? -> 객체를 공유하도록 하는 것

순수 자바 DI컨테이너는 호출 시 객체를 새로 생성함. 만약 실제 웹이라면?
여러 고객의 요청에 각각 새로운 객체를 생성하여 매우 비효율적임. 이를 극복하기 위해
싱글톤 패턴이 고안되었다.

객체에 접근하는 방법을 해당 클래스의 static method (getInstance)로
제약. 해당 method에서는 static영역의 private final 객체를 반환한다.
+생성자는 private으로 선언해서 다른 객체는 못만들게 한다.
-> 이건 사실 그렇게 좋은 방식은 아님...

스프링 빈은? 싱글톤이다~ 이걸 쓰면 된다~

싱글톤 방식은 stateless로 설계해야함.
- 특정 클라이언트에 의존적인 필드가 있으면 안된다.
- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
- 가급적 읽기만 가능해야 한다.
- 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다

이상한 점 하나. Config에서 스프링 빈의 생성 과정에서 new로 객체를 생성하는 부분이 나옴.
이거 싱글톤을 깨는 것 아닌가?
-> @Configuration에서 Config 클래스의 바이트 코드를 조작하여 싱글톤을 보장한다.
실제로 @Configuration을 빼고 빈을 등록하면, 싱글톤을 보장하지 않는다.